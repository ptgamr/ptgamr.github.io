{"componentChunkName":"component---src-templates-blog-post-js","path":"/2014-07-23-angulars-dependency-injection-annotation-process/","result":{"data":{"site":{"siteMetadata":{"title":"Anh Trinh's blog"}},"markdownRemark":{"id":"3b619757-fed2-56d6-82b9-9a8b3758854e","excerpt":"Source: Todd Motto For those familiar with Angular’s dependency injection (DI), this post will dive into some of the “under the hood” methods that power the DI…","html":"<p>Source: <a href=\"http://toddmotto.com/angular-js-dependency-injection-annotation-process/?utm_source=ng-newsletter&#x26;utm_campaign=a23834faa2-AngularJS_Newsletter_7_22_147_22_2014&#x26;utm_medium=email&#x26;utm_term=0_fa61364f13-a23834faa2-92599937\">Todd Motto</a></p>\n<p>For those familiar with Angular’s dependency injection (DI), this post will dive into some of the “under the hood” methods that power the DI process. For those who aren’t familiar with the concept, DI is a way of asking for necessary dependencies instead of passing them. We merely tell a method, function, object what dependencies we want - and tucked away we get our dependencies given to us.</p>\n<p>So, how does this work in AngularJS?</p>\n<p>Until now, I’ve kind of let it be a black box - it just works and I use it. But after a stint of looking through the source code, I think I’ve cracked how it all works underneath - and the implementation is <em>so</em> clever and simple - it’s definitely worth looking into. I’ve also learned a few things along the way!</p>\n<h3>Dependency injection in Angular</h3>\n<p>There are three ways we can pass dependencies into Angular functions, the first cannot be minified without breaking the app, the second annotations aid minification aliasing - let’s look at them.</p>\n<h4>1. Function arguments</h4>\n<p>Function arguments work perfectly until we minify our app. Minification is important as we want to compress our JavaScript as much as possible, for obfuscation but mainly for performance purposes.</p>\n<p>Let’s see how that works:</p>\n<div class=\"gatsby-highlight\" data-language=\"language-javascript\"><pre class=\"language-language-javascript\"><code class=\"language-language-javascript\">    function SomeCtrl ($scope) {\n      // do something with $scope\n    }\n\n    angular\n      .module(&#39;app&#39;, [])\n      .controller(&#39;SomeCtrl&#39;, SomeCtrl);</code></pre></div>\n<p>Easy, we just pass in <code class=\"language-text\">$scope</code> as an argument and Angular passes it in for us.</p>\n<h4>2: Array arguments</h4>\n<p>Possibly the most common way to do it, we pass in an Array to an Angular module method, we’ll use a Controller in all examples to keep things easy and consistent.</p>\n<div class=\"gatsby-highlight\" data-language=\"language-javascript\"><pre class=\"language-language-javascript\"><code class=\"language-language-javascript\">    function SomeCtrl ($scope) {\n      // do something with $scope\n    }\n\n    angular\n      .module(&#39;app&#39;, [])\n      .controller(&#39;SomeCtrl&#39;, [&#39;$scope&#39;, SomeCtrl]);</code></pre></div>\n<p>This is also commonly seen as this, however, with functions inside the <code class=\"language-text\">.controller()</code> method:</p>\n<div class=\"gatsby-highlight\" data-language=\"language-javascript\"><pre class=\"language-language-javascript\"><code class=\"language-language-javascript\">    angular\n      .module(&#39;app&#39;, [])\n      .controller(&#39;SomeCtrl&#39;, [&#39;$scope&#39;, function SomeCtrl ($scope) {\n        // do something with $scope\n      }]);</code></pre></div>\n<p><a href=\"//twitter.com/John_Papa\">John Papa</a> and I have been discussing the first pattern in depth recently and advocate it’s use over the latter, that’s another story though.</p>\n<h4>3. $inject</h4>\n<p>Using <code class=\"language-text\">$inject</code> makes things simple, and does the same as the above by annotating the dependencies:</p>\n<div class=\"gatsby-highlight\" data-language=\"language-javascript\"><pre class=\"language-language-javascript\"><code class=\"language-language-javascript\">    function SomeCtrl ($scope) {\n      // do something with $scope\n    }\n\n    SomeCtrl.$inject = [&#39;$scope&#39;];\n\n    angular\n      .module(&#39;app&#39;, [])\n      .controller(&#39;SomeCtrl&#39;, SomeCtrl);</code></pre></div>\n<h5>What does this mean though?</h5>\n<p>It means when our application is minified, dependency references remain intact due to Angular’s internal annotations, for example <code class=\"language-text\">function ($scope) {}</code> becoming <code class=\"language-text\">function (a) {}</code> . Visual example:</p>\n<div class=\"gatsby-highlight\" data-language=\"language-javascript\"><pre class=\"language-language-javascript\"><code class=\"language-language-javascript\">    function SomeCtrl (a) {\n      // a = $scope\n    }\n\n    SomeCtrl.$inject = [&#39;$scope&#39;];\n\n    angular\n      .module(&#39;app&#39;, [])\n      .controller(&#39;SomeCtrl&#39;, SomeCtrl);</code></pre></div>\n<p>Angular magically maps this <code class=\"language-text\">[&#39;$scope&#39;]</code> dependency onto the local <code class=\"language-text\">a</code> argument variable - how does it know?!…</p>\n<h3>Annotation process</h3>\n<p>This is where things get seriously awesome, we’re out of API land now and deep within Angular’s source code. How does Angular map our dependencies then onto minified variables? Let’s find out.</p>\n<p>First, there’s a bunch of <code class=\"language-text\">RegExp</code> variables in the source, these play a part in it ;)</p>\n<div class=\"gatsby-highlight\" data-language=\"language-javascript\"><pre class=\"language-language-javascript\"><code class=\"language-language-javascript\">    var FN_ARGS = /^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m;\n    var FN_ARG_SPLIT = /,/;\n    var FN_ARG = /^\\s*(_?)(\\S+?)\\1\\s*$/;\n    var STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;</code></pre></div>\n<p>There’s a bunch of steps that each of these RegExps correspond with, let’s follow them:</p>\n<p>Angular turns a function it needs to annotate into a <code class=\"language-text\">String</code>, then reads what you’ve passed in and changes that into an Array of arguments and returns it. First, it calls the <code class=\"language-text\">toString</code> method on the function - I’m going to recreate the bare basics of this - it won’t be a direct copy of the source code.</p>\n<div class=\"gatsby-highlight\" data-language=\"language-javascript\"><pre class=\"language-language-javascript\"><code class=\"language-language-javascript\">    // declare our function\n    function ExampleMethod ($scope, /* $rootScope needed! */$rootScope, SomeService) {\n\n    }\n\n    // call toString on it\n    var fnString = ExampleMethod.toString();\n\n    // &quot;function ExampleMethod($scope, /* $rootScope needed! */$rootScope, SomeService) {}&quot;\n    console.log(fnString);</code></pre></div>\n<p>What now? Someone’s put a comment in the arguments (totally cool) but Angular needs to do some more work on this. Enter, the <code class=\"language-text\">STRIP_COMMENTS</code> constant:</p>\n<div class=\"gatsby-highlight\" data-language=\"language-javascript\"><pre class=\"language-language-javascript\"><code class=\"language-language-javascript\">    // &quot;function ExampleMethod($scope, $rootScope, SomeService) {}&quot;\n    fnString.replace(STRIP_COMMENTS, &#39;&#39;);</code></pre></div>\n<p>With the comments gone, Angular moves onto the next phase and calls <code class=\"language-text\">String.prototype.match</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"language-javascript\"><pre class=\"language-language-javascript\"><code class=\"language-language-javascript\">    /*\n      [\n        &quot;function ExampleMethod($scope, $rootScope, SomeService) {}&quot;,\n        &quot;$scope, $rootScope, SomeService&quot;\n      ]\n    */\n    fnString.match(FN_ARGS);</code></pre></div>\n<p>We then get the above <code class=\"language-text\">Array</code> as the output. We don’t care about the first part, we just want the comma separated second item in the <code class=\"language-text\">Array</code>, which means we would do this instead to get just the <code class=\"language-text\">String</code> value of the second item:</p>\n<div class=\"gatsby-highlight\" data-language=\"language-javascript\"><pre class=\"language-language-javascript\"><code class=\"language-language-javascript\">    /*\n      &quot;$scope, $rootScope, SomeService&quot;\n    */\n    fnString.match(FN_ARGS)[1];</code></pre></div>\n<p>Next, Angular calls <code class=\"language-text\">fnString.split(FN_ARG_SPLIT);</code>, which returns an <code class=\"language-text\">Array</code> of our <code class=\"language-text\">arguments</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"language-javascript\"><pre class=\"language-language-javascript\"><code class=\"language-language-javascript\">    // [&quot;$scope&quot;, &quot; $rootScope&quot;, &quot; SomeService&quot;]\n    fnString.split(FN_ARG_SPLIT);</code></pre></div>\n<p>You’ll notice that some of the <code class=\"language-text\">Array</code> items have a single space before the name, such as <code class=\"language-text\">&quot; $rootScope&quot;</code>, this is because the function arguments were separated with a comma then space. Angular then loops over these final <code class=\"language-text\">Array</code> items, replaces function arg whitespace and pushes them into a <em>new</em> <code class=\"language-text\">Array</code> called <code class=\"language-text\">$inject</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"language-javascript\"><pre class=\"language-language-javascript\"><code class=\"language-language-javascript\">    var $inject = [];\n    var args = fnString.split(FN_ARG_SPLIT);\n    args.forEach(function (arg) {\n      arg.replace(FN_ARG, function (all, underscore, name) {\n        $inject.push(name);\n      });\n    });\n    return $inject;</code></pre></div>\n<p>The function returns <code class=\"language-text\">$inject</code>. And we’re done. Putting the above together, I can replicate what Angular does (in a very simple form):</p>\n<div class=\"gatsby-highlight\" data-language=\"language-javascript\"><pre class=\"language-language-javascript\"><code class=\"language-language-javascript\">    var FN_ARGS = /^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m;\n    var FN_ARG_SPLIT = /,/;\n    var FN_ARG = /^\\s*(_?)(\\S+?)\\1\\s*$/;\n    var STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n\n    function annotate (fn) {\n      var $inject = [];\n      fn = fn.toString();\n      var first = fn.replace(STRIP_COMMENTS, &#39;&#39;);\n      var second = first.match(FN_ARGS)[1];\n      var third = second.split(FN_ARG_SPLIT);\n      third.forEach(function (arg) {\n        arg.replace(FN_ARG, function (all, underscore, name) {\n          $inject.push(name);\n        });\n      });\n      return $inject;\n    }</code></pre></div>\n<p>Nice! Here’s how it works:</p>\n<div class=\"gatsby-highlight\" data-language=\"language-javascript\"><pre class=\"language-language-javascript\"><code class=\"language-language-javascript\">    function ExampleMethod ($scope, /* $rootScope needed! */$rootScope, SomeService) {\n\n    }\n    var annotated = annotate(ExampleMethod);\n\n    // [&quot;$scope&quot;, &quot;$rootScope&quot;, &quot;SomeService&quot;]\n    console.log(annotated);</code></pre></div>\n<p>This only takes into account arguments being named correctly, such as <code class=\"language-text\">$scope</code> instead of minified <code class=\"language-text\">a</code>. This means that the above method is only for annotating functions that haven’t been minified or have no Array dependencies, in other words, this code isn’t used in production if you’re minifying your code.</p>\n<h4>Annotating the Array syntax</h4>\n<p>This is actually really simple! Take our <code class=\"language-text\">Array</code> setup, I can pass it into my <code class=\"language-text\">annotate</code> function:</p>\n<div class=\"gatsby-highlight\" data-language=\"language-javascript\"><pre class=\"language-language-javascript\"><code class=\"language-language-javascript\">    function ExampleMethod ($scope, /* $rootScope needed! */$rootScope, SomeService) {\n\n    }\n    var arraySyntax = [&#39;$scope&#39;, &#39;$rootScope&#39;, &#39;SomeService&#39;, ExampleMethod];\n    var annotated = annotate(arraySyntax);\n\n    // [&quot;$scope&quot;, &quot;$rootScope&quot;, &quot;SomeService&quot;]\n    console.log(annotated);</code></pre></div>\n<p>If we’re already this example, then Angular doesn’t need to grab the names as above, it assumes you’ve already supplied them correctly and uses your <code class=\"language-text\">Array</code> order as the new arguments order, using this line in the source:</p>\n<div class=\"gatsby-highlight\" data-language=\"language-javascript\"><pre class=\"language-language-javascript\"><code class=\"language-language-javascript\">    ...\n    else if (isArray(fn)) {\n      last = fn.length - 1;\n      assertArgFn(fn[last], &#39;fn&#39;);\n      $inject = fn.slice(0, last);\n    }\n    ...\n\nWe&#39;re only interested in this part:\n\n\n    ...\n    else if (isArray(fn)) {\n      last = fn.length - 1;\n      $inject = fn.slice(0, last);\n    }\n    ...</code></pre></div>\n<p>What does it do? The <code class=\"language-text\">last</code> variable holds the <code class=\"language-text\">Array.length - 1</code>, which (very cleverly) the last item in our <code class=\"language-text\">Array</code> is the function to be invoked (the <code class=\"language-text\">arraySyntax</code> variable I just created above). We could write a <em>tiny</em> function to do exactly that:</p>\n<div class=\"gatsby-highlight\" data-language=\"language-javascript\"><pre class=\"language-language-javascript\"><code class=\"language-language-javascript\">    function annotate (fn) {\n      var $inject = [];\n      $inject = fn.slice(0, fn.length - 1);\n      return $inject;\n    }</code></pre></div>\n<p>Or even:</p>\n<div class=\"gatsby-highlight\" data-language=\"language-javascript\"><pre class=\"language-language-javascript\"><code class=\"language-language-javascript\">    function annotate (fn) {\n      return fn.slice(0, fn.length - 1);\n    }</code></pre></div>\n<p>Both would output what we need, as <code class=\"language-text\">Array.prototype.slice</code> returns a portion of an <code class=\"language-text\">Array</code>, which Angular says to be the length of the <code class=\"language-text\">Array</code>, minus <code class=\"language-text\">1</code> - omitting our <code class=\"language-text\">function</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"language-javascript\"><pre class=\"language-language-javascript\"><code class=\"language-language-javascript\">    function annotate (fn) {\n      return fn.slice(0, fn.length - 1);\n    }\n\n    // returns [&quot;$scope&quot;, &quot;$rootScope&quot;, &quot;SomeService&quot;]\n    var annotated = annotate([\n      &#39;$scope&#39;,\n      &#39;$rootScope&#39;,\n      &#39;SomeService&#39;,\n      function ExampleMethod ($scope, $rootScope, SomeService) {}\n    ]);</code></pre></div>\n<h4>Annotating $inject</h4>\n<p>Inside Angular’s annotate function, it also checks to see if <code class=\"language-text\">fn.$inject</code> exists, if it does, it can just return those, as we’ll have provided a setup like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"language-javascript\"><pre class=\"language-language-javascript\"><code class=\"language-language-javascript\">    function ExampleMethod ($scope, $rootScope, SomeService) {\n\n    }\n    ExampleMethod.$inject = [&#39;$scope&#39;, &#39;$rootScope&#39;, &#39;SomeService&#39;];</code></pre></div>\n<p><code class=\"language-text\">ExampleMethod.$inject</code> is a straight up <code class=\"language-text\">Array</code>, and Angular will run with that.</p>\n<h3>Mapping function arguments</h3>\n<p>This took some further digging, and the way Angular maps minified function arguments to real names is <em>so</em> unbelievably simple! The steps are:</p>\n<ul>\n<li>Get the dependecy list in Array form (as we have above)</li>\n<li>Apply the dependencies list over the top of the minified variables (pass them in as arguments when invoking the function)</li>\n</ul>\n<p>We’ve already completed the first step, let’s assume we have <code class=\"language-text\">[&#39;$scope&#39;, &#39;$rootScope&#39;, &#39;SomeService&#39;]</code> on standby from an <code class=\"language-text\">$inject</code> property on the function, and the said function with minified arguments:</p>\n<div class=\"gatsby-highlight\" data-language=\"language-javascript\"><pre class=\"language-language-javascript\"><code class=\"language-language-javascript\">    function ExampleMethod (a, b, c) {\n\n    }\n    ExampleMethod.$inject = [&#39;$scope&#39;, &#39;$rootScope&#39;, &#39;SomeService&#39;];</code></pre></div>\n<p>How does <code class=\"language-text\">$scope</code> match up with <code class=\"language-text\">a</code>? Easy:</p>\n<div class=\"gatsby-highlight\" data-language=\"language-javascript\"><pre class=\"language-language-javascript\"><code class=\"language-language-javascript\">    function ExampleMethod (a, b, c) {\n      console.log(a, b, c);\n    }\n    ExampleMethod.$inject = [&#39;$scope&#39;, &#39;$rootScope&#39;, &#39;SomeService&#39;];\n    ExampleMethod.apply(null, ExampleMethod.$inject);</code></pre></div>\n<p>Three lines to completely remap the underlying argument names. As they’re just placeholder arguments anyway (which Angular has read and passed in what we actually want, there isn’t really “remapping” going on, but it feels like it). This is just a simple case of invoking the function based off a predefined arguments list.</p>\n<p>Angular doesn’t do much with the <code class=\"language-text\">$inject</code> property, it just gets returned from the function (after a few function checks, no manipulation), so I’ve left it out of my remade <code class=\"language-text\">annotate</code> function as it’ll just get returned as is.</p>\n<h3>Altogether now</h3>\n<p>Let’s slap it all together. </p>\n<div class=\"gatsby-highlight\" data-language=\"language-javascript\"><pre class=\"language-language-javascript\"><code class=\"language-language-javascript\">    /**\n     * annotate remake\n     */\n    var FN_ARGS = /^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m;\n    var FN_ARG_SPLIT = /,/;\n    var FN_ARG = /^\\s*(_?)(\\S+?)\\1\\s*$/;\n    var STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\n\n    function annotate (fn) {\n        var $inject;\n        if (typeof fn === &#39;function&#39;) {\n            $inject = [];\n            fn = fn.toString();\n            var first = fn.replace(STRIP_COMMENTS, &#39;&#39;);\n            var second = first.match(FN_ARGS)[1];\n            var third = second.split(FN_ARG_SPLIT);\n            third.forEach(function (arg) {\n                arg.replace(FN_ARG, function(all, underscore, name){\n                    $inject.push(name);\n                  });\n            });\n        } else {\n            $inject = fn.slice(0, fn.length - 1);\n        }\n        return $inject;\n    }\n\n    /**\n     * functions\n     */\n    function withoutDependencies ($scope, $rootScope, SomeFactory) {\n      // $scope, $rootScope, SomeFactory\n      console.log($scope, $rootScope, SomeFactory);\n    }\n    function withDependencies (a, b, c) {\n      // BOOM! We did it!\n      // $scope, $rootScope, SomeFactory\n      console.log(a, b, c);\n    }\n\n    var annotatedWithout = annotate(withoutDependencies);\n    withoutDependencies.apply(null, annotatedWithout);\n\n    var annotatedWith = annotate([&#39;$scope&#39;, &#39;$rootScope&#39;, &#39;SomeFactory&#39;, withDependencies]);\n    withDependencies.apply(null, annotatedWith);</code></pre></div>\n<p>The above <code class=\"language-text\">annotate</code> function invokes the <code class=\"language-text\">withoutDependencies</code> function without any dependencies, so <code class=\"language-text\">annotate</code> loops through the arguments and invokes it with each argument name directly. The <code class=\"language-text\">withDependencies</code> function is looking for <code class=\"language-text\">a, b, c</code> arguments, but what are they? We grab <code class=\"language-text\">$scope, $rootScope, SomeFactory</code> from the <code class=\"language-text\">$inject</code> property and use <code class=\"language-text\">Function.prototype.apply</code> to invoke the function with our <code class=\"language-text\">$inject</code> Array of arguments.</p>\n<p>That’s it! This doesn’t cover how Angular physically “injects” the actual dependencies, but how it resolves the dependency names internally, I thought it was really clever, and learned a thing or two from the source. Here’s the end result in a <a href=\"http://jsfiddle.net/toddmotto/fgFWL\">jsFiddle</a>, inspect the <code class=\"language-text\">console</code> to see it working.</p>\n<h3>Best route for performance?</h3>\n<p>Based on the following conditions in the <a href=\"https://code.angularjs.org/1.3.0-beta.7/angular.js\">Angular source</a>, using <code class=\"language-text\">$inject</code> would be best for performance! I’ve annotated the good parts of the function:</p>\n<div class=\"gatsby-highlight\" data-language=\"language-javascript\"><pre class=\"language-language-javascript\"><code class=\"language-language-javascript\">    function annotate(fn, strictDi, name) {\n      var $inject,\n          fnText,\n          argDecl,\n          last;\n\n      // if the function passed in is a function, let&#39;s roll with it...\n      // ...there are two things that can happen inside here, either we&#39;re using $inject or\n      // we aren&#39;t using $inject, which means we&#39;ll manually need to get the dependencies\n      // from the arguments\n      if (typeof fn === &#39;function&#39;) {\n\n        // !($inject = fn.$inject) checks for the presence\n        // of fn.$inject and assigns it to the $inject variable, if this is true\n        // there is no further action needed, and $inject is returned\n        // which is a very fast operation\n        if (!($inject = fn.$inject)) {\n\n          // if fn.$inject doesn&#39;t exist, it&#39;s bad news and we&#39;re going to need to\n          // do some manual work reading the dependencies from the arguments, so they\n          // need to be spelled correctly against the proper names or they&#39;ll be an\n          // unknown provider\n          $inject = [];\n          if (fn.length) {\n            if (strictDi) {\n              if (!isString(name) || !name) {\n                name = fn.name || anonFn(fn);\n              }\n              throw $injectorMinErr(&#39;strictdi&#39;,\n                &#39;{0} is not using explicit annotation and cannot be invoked in strict mode&#39;, name);\n            }\n            fnText = fn.toString().replace(STRIP_COMMENTS, &#39;&#39;);\n            argDecl = fnText.match(FN_ARGS);\n            forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg){\n              arg.replace(FN_ARG, function(all, underscore, name){\n                $inject.push(name);\n              });\n            });\n          }\n          // here after we&#39;re done, it completes what we wanted before this \n          // operation, the fn.$inject, so it just assigns $inject to the function\n          // and $inject gets returned below\n          fn.$inject = $inject;\n        }\n      } else if (isArray(fn)) {\n        // if the function isn&#39;t a function, but is an Array containing a function\n        // we need to remove it from the Array and send the leftover portion of the\n        // Array back as $inject\n\n        // calculate the Array length\n        last = fn.length - 1;\n        assertArgFn(fn[last], &#39;fn&#39;);\n\n        // use slice which returns the portion of the Array minus the final item\n        $inject = fn.slice(0, last);\n      } else {\n        assertArgFn(fn, &#39;fn&#39;, true);\n      }\n      // returns $inject from one of the methods above!\n      return $inject;\n    }</code></pre></div>\n<p>Want to dig in more? Search for this <code class=\"language-text\">function annotate</code> to find this implementation, and <code class=\"language-text\">function invoke</code> to see where the <code class=\"language-text\">.apply()</code> call takes place and how the two hang together.</p>","frontmatter":{"title":"Angular’s dependency injection annotation process","date":"July 22, 2014","description":null}}},"pageContext":{"slug":"/2014-07-23-angulars-dependency-injection-annotation-process/","previous":{"fields":{"slug":"/2014-07-20-correct-way-to-integrate-cordova-plugin-in-angularjs-ionic-framework/"},"frontmatter":{"title":"Correct way to integrate Cordova Plugin in AngularJS, Ionic Framework"}},"next":{"fields":{"slug":"/2014-08-07-how-pinterest-construct-their-layout/"},"frontmatter":{"title":"How Pinterest construct their layout?"}}}},"staticQueryHashes":["2841359383","916993862"]}